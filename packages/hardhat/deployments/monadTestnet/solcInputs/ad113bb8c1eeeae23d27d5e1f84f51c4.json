{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/PokerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IAgentReputationRegistry {\n    function giveFeedback(uint256 agentId, int128 value, string calldata tag) external returns (uint64);\n}\n\n/**\n * PokerVault — escrow for agentic poker tournaments.\n *\n * Agents are ephemeral by default: they exist only within a tournament and are defined\n * by a name + system prompt submitted at entry time. Optionally, agents may link\n * a persistent ERC-8004 identity (agentId > 0) to build on-chain reputation.\n *\n * Responsibilities:\n *   - Accept buy-ins in MON (native token) when agents enter tournaments\n *   - Hold prize pools while games run\n *   - Pay out the full prize pool to the winner's wallet\n *   - Post win/loss feedback to the ERC-8004 Reputation Registry (if configured)\n *\n * Game logic (cards, betting, hand evaluation) is entirely off-chain.\n * The operator (agent-runner service) is trusted to report the winner.\n */\ncontract PokerVault is Ownable {\n\n    // ─────────────────────────────────────────────\n    // Types\n    // ─────────────────────────────────────────────\n\n    struct Agent {\n        address wallet;       // wallet that entered; receives winnings if they win\n        string  name;\n        string  systemPrompt;\n        uint256 agentId;      // ERC-8004 identity token ID (0 = ephemeral, unregistered)\n    }\n\n    enum TournamentStatus { Open, Running, Finished }\n\n    struct Tournament {\n        uint256 buyIn;\n        uint256 prizePool;\n        TournamentStatus status;\n        uint8   maxPlayers;\n        address creator;\n        Agent[] agents;\n    }\n\n    // ─────────────────────────────────────────────\n    // State\n    // ─────────────────────────────────────────────\n\n    address public operator;\n\n    uint256 public nextTournamentId = 1;\n    uint256 public activeTournamentId;\n\n    mapping(uint256 => Tournament) public tournaments;\n\n    // ERC-8004 Reputation Registry — optional, address(0) means disabled\n    IAgentReputationRegistry public reputationRegistry;\n\n    // ─────────────────────────────────────────────\n    // Events\n    // ─────────────────────────────────────────────\n\n    event TournamentCreated(uint256 indexed tournamentId, uint256 buyIn, uint8 maxPlayers);\n    event AgentEntered(uint256 indexed tournamentId, uint256 indexed seatIndex, address indexed wallet, string name, uint256 agentId);\n    event TournamentStarted(uint256 indexed tournamentId, uint256 playerCount);\n    event TournamentSettled(uint256 indexed tournamentId, uint256 indexed winningSeat, address indexed winner, uint256 payout);\n\n    // ─────────────────────────────────────────────\n    // Modifiers\n    // ─────────────────────────────────────────────\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Not the operator\");\n        _;\n    }\n\n    // ─────────────────────────────────────────────\n    // Constructor\n    // ─────────────────────────────────────────────\n\n    constructor(address _operator) Ownable(msg.sender) {\n        operator = _operator;\n    }\n\n    // ─────────────────────────────────────────────\n    // Tournament management\n    // ─────────────────────────────────────────────\n\n    /**\n     * Create a new tournament. Only the operator can create one.\n     * @param buyIn      Amount in wei each agent must send to enter (0 = free).\n     * @param maxPlayers Maximum number of agents allowed.\n     */\n    function createTournament(uint256 buyIn, uint8 maxPlayers) external onlyOperator returns (uint256 tournamentId) {\n        require(maxPlayers >= 2, \"Need at least 2 players\");\n        require(activeTournamentId == 0, \"Active tournament exists\");\n        tournamentId = nextTournamentId++;\n        tournaments[tournamentId].buyIn      = buyIn;\n        tournaments[tournamentId].maxPlayers = maxPlayers;\n        tournaments[tournamentId].status     = TournamentStatus.Open;\n        tournaments[tournamentId].creator    = msg.sender;\n        activeTournamentId = tournamentId;\n        emit TournamentCreated(tournamentId, buyIn, maxPlayers);\n    }\n\n    /**\n     * Enter a tournament with a new agent. Must send exactly the buy-in in MON.\n     * @param tournamentId Tournament to enter.\n     * @param name         Display name for the agent.\n     * @param systemPrompt The AI system prompt that drives this agent's decisions.\n     * @param agentId      ERC-8004 identity token ID to link (0 = ephemeral).\n     */\n    function enterTournament(\n        uint256 tournamentId,\n        string calldata name,\n        string calldata systemPrompt,\n        uint256 agentId\n    ) external payable returns (uint256 seatIndex) {\n        Tournament storage t = tournaments[tournamentId];\n        require(t.status == TournamentStatus.Open, \"Tournament not open\");\n        require(t.agents.length < t.maxPlayers, \"Tournament full\");\n        require(bytes(name).length > 0, \"Name required\");\n        require(msg.value == t.buyIn, \"Wrong buy-in amount\");\n\n        seatIndex = t.agents.length;\n        t.agents.push(Agent({ wallet: msg.sender, name: name, systemPrompt: systemPrompt, agentId: agentId }));\n        t.prizePool += msg.value;\n\n        emit AgentEntered(tournamentId, seatIndex, msg.sender, name, agentId);\n    }\n\n    /**\n     * Start a tournament. The tournament creator OR the operator can call this.\n     * Emits TournamentStarted so the agent-runner can read agent data and begin the game.\n     */\n    function startTournament(uint256 tournamentId) external {\n        Tournament storage t = tournaments[tournamentId];\n        require(msg.sender == t.creator || msg.sender == operator, \"Not creator or operator\");\n        require(t.status == TournamentStatus.Open, \"Tournament not open\");\n        require(t.agents.length >= 4, \"Need at least 4 players\");\n        t.status = TournamentStatus.Running;\n        emit TournamentStarted(tournamentId, t.agents.length);\n    }\n\n    /**\n     * Settle a finished tournament. Only the operator can call this.\n     * Transfers the full prize pool to the winning agent's wallet.\n     * If the ERC-8004 Reputation Registry is configured, posts win/loss feedback\n     * for all agents that have a registered identity (agentId > 0).\n     * @param tournamentId Tournament being settled.\n     * @param winningSeat  Seat index (0-based) of the winning agent.\n     */\n    function settleTournament(uint256 tournamentId, uint256 winningSeat) external onlyOperator {\n        Tournament storage t = tournaments[tournamentId];\n        require(t.status == TournamentStatus.Running, \"Tournament not running\");\n        require(winningSeat < t.agents.length, \"Invalid seat\");\n\n        t.status = TournamentStatus.Finished;\n\n        address winner = t.agents[winningSeat].wallet;\n        uint256 payout = t.prizePool;\n        t.prizePool = 0;\n\n        emit TournamentSettled(tournamentId, winningSeat, winner, payout);\n        if (activeTournamentId == tournamentId) {\n            activeTournamentId = 0;\n        }\n\n        // Post ERC-8004 reputation feedback for all registered agents\n        if (address(reputationRegistry) != address(0)) {\n            for (uint256 i = 0; i < t.agents.length; i++) {\n                uint256 aid = t.agents[i].agentId;\n                if (aid > 0) {\n                    int128 score = (i == winningSeat) ? int128(1) : int128(-1);\n                    // Ignore failures so settlement never gets blocked\n                    try reputationRegistry.giveFeedback(aid, score, \"poker-tournament\") {} catch {}\n                }\n            }\n        }\n\n        (bool success, ) = winner.call{ value: payout }(\"\");\n        require(success, \"Payout failed\");\n    }\n\n    // ─────────────────────────────────────────────\n    // View helpers\n    // ─────────────────────────────────────────────\n\n    function getTournamentCreator(uint256 tournamentId) external view returns (address) {\n        return tournaments[tournamentId].creator;\n    }\n\n    function getTournamentAgents(uint256 tournamentId) external view returns (Agent[] memory) {\n        return tournaments[tournamentId].agents;\n    }\n\n    function getTournamentAgent(uint256 tournamentId, uint256 seatIndex) external view returns (Agent memory) {\n        return tournaments[tournamentId].agents[seatIndex];\n    }\n\n    function getAgentCount(uint256 tournamentId) external view returns (uint256) {\n        return tournaments[tournamentId].agents.length;\n    }\n\n    // ─────────────────────────────────────────────\n    // Admin\n    // ─────────────────────────────────────────────\n\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n    }\n\n    /**\n     * Wire in the ERC-8004 Reputation Registry. Pass address(0) to disable.\n     */\n    function setReputationRegistry(address _registry) external onlyOwner {\n        reputationRegistry = IAgentReputationRegistry(_registry);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/TournamentBetting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IPokerVault {\n    function tournaments(uint256 tournamentId) external view returns (\n        uint256 buyIn,\n        uint256 prizePool,\n        uint8   status,\n        uint8   maxPlayers,\n        address creator\n    );\n}\n\n/**\n * TournamentBetting — parimutuel betting pool for PokerVault tournaments.\n *\n * Spectators can bet MON on which agent seat they think will win while\n * the tournament is Open. Once settled, winners share the total pool\n * proportionally to their stake (minus a small platform fee).\n *\n * Betting lifecycle:\n *   1. placeBet()       — while tournament is Open\n *   2. (tournament runs)\n *   3. settleBetting()  — operator calls after PokerVault.settleTournament()\n *   4. claimWinnings()  — winners pull their share\n */\ncontract TournamentBetting is Ownable {\n\n    // ─────────────────────────────────────────────\n    // State\n    // ─────────────────────────────────────────────\n\n    IPokerVault public immutable pokerVault;\n\n    address public operator;\n\n    // Platform fee in basis points (100 bps = 1%). Default 5%.\n    uint256 public platformFeeBps = 500;\n\n    uint256 public constant MIN_BET = 0.001 ether;\n\n    // tournamentId => seatIndex => bettor => bet amount\n    mapping(uint256 => mapping(uint256 => mapping(address => uint256))) public bets;\n\n    // tournamentId => seatIndex => total amount bet on that seat\n    mapping(uint256 => mapping(uint256 => uint256)) public seatTotals;\n\n    // tournamentId => total amount in the betting pool\n    mapping(uint256 => uint256) public totalPool;\n\n    // tournamentId => whether betting has been settled\n    mapping(uint256 => bool) private _settled;\n\n    // tournamentId => winning seat (only valid when _settled is true)\n    mapping(uint256 => uint256) private _winningSeat;\n\n    // tournamentId => payout pool (totalPool minus platform fee, set on settlement)\n    mapping(uint256 => uint256) private _payoutPool;\n\n    // tournamentId => bettor => has claimed winnings\n    mapping(uint256 => mapping(address => bool)) public claimed;\n\n    // ─────────────────────────────────────────────\n    // Events\n    // ─────────────────────────────────────────────\n\n    event BetPlaced(\n        uint256 indexed tournamentId,\n        uint256 indexed seatIndex,\n        address indexed bettor,\n        uint256 amount\n    );\n    event BettingSettled(\n        uint256 indexed tournamentId,\n        uint256 indexed winningSeat,\n        uint256 totalPool,\n        uint256 platformFee\n    );\n    event WinningsClaimed(\n        uint256 indexed tournamentId,\n        address indexed bettor,\n        uint256 amount\n    );\n\n    // ─────────────────────────────────────────────\n    // Constructor\n    // ─────────────────────────────────────────────\n\n    constructor(address _pokerVault, address _operator) Ownable(msg.sender) {\n        pokerVault = IPokerVault(_pokerVault);\n        operator = _operator;\n    }\n\n    // ─────────────────────────────────────────────\n    // Betting\n    // ─────────────────────────────────────────────\n\n    /**\n     * Place a bet on an agent seat. Only allowed while the tournament is Open.\n     * Multiple bets on the same seat accumulate; betting different seats is allowed.\n     * @param tournamentId The PokerVault tournament ID.\n     * @param seatIndex    The 0-based agent seat to bet on.\n     */\n    function placeBet(uint256 tournamentId, uint256 seatIndex) external payable {\n        require(msg.value >= MIN_BET, \"Bet below minimum\");\n\n        (, , uint8 status, uint8 maxPlayers, ) = pokerVault.tournaments(tournamentId);\n        require(status == 0, \"Betting closed (tournament not open)\");\n        require(seatIndex < maxPlayers, \"Seat out of range\");\n\n        bets[tournamentId][seatIndex][msg.sender] += msg.value;\n        seatTotals[tournamentId][seatIndex] += msg.value;\n        totalPool[tournamentId] += msg.value;\n\n        emit BetPlaced(tournamentId, seatIndex, msg.sender, msg.value);\n    }\n\n    /**\n     * Settle betting for a finished tournament. Only the operator can call this.\n     * Must be called after PokerVault.settleTournament() so status == Finished.\n     * Deducts the platform fee and transfers it to the contract owner.\n     * @param tournamentId The tournament ID.\n     * @param winningSeat  The winning seat (must match PokerVault result).\n     */\n    function settleBetting(uint256 tournamentId, uint256 winningSeat) external {\n        require(msg.sender == operator, \"Not operator\");\n\n        (, , uint8 status, , ) = pokerVault.tournaments(tournamentId);\n        require(status == 2, \"Tournament not finished\");\n        require(!_settled[tournamentId], \"Already settled\");\n\n        _settled[tournamentId] = true;\n        _winningSeat[tournamentId] = winningSeat;\n\n        uint256 pool = totalPool[tournamentId];\n\n        if (pool == 0) {\n            emit BettingSettled(tournamentId, winningSeat, 0, 0);\n            return;\n        }\n\n        // If no bets on the winning seat, send the whole pool to the owner (edge case)\n        if (seatTotals[tournamentId][winningSeat] == 0) {\n            (bool ok, ) = owner().call{ value: pool }(\"\");\n            require(ok, \"Fee transfer failed\");\n            emit BettingSettled(tournamentId, winningSeat, pool, pool);\n            return;\n        }\n\n        uint256 fee = (pool * platformFeeBps) / 10000;\n        if (fee > 0) {\n            (bool ok, ) = owner().call{ value: fee }(\"\");\n            require(ok, \"Fee transfer failed\");\n        }\n\n        _payoutPool[tournamentId] = pool - fee;\n\n        emit BettingSettled(tournamentId, winningSeat, pool, fee);\n    }\n\n    /**\n     * Claim winnings after betting is settled. Pull-pattern to avoid failed sends.\n     * Winners share the payout pool proportional to their stake on the winning seat.\n     */\n    function claimWinnings(uint256 tournamentId) external {\n        require(_settled[tournamentId], \"Betting not settled yet\");\n        uint256 winningSeat = _winningSeat[tournamentId];\n\n        require(!claimed[tournamentId][msg.sender], \"Already claimed\");\n\n        uint256 userBet = bets[tournamentId][winningSeat][msg.sender];\n        require(userBet > 0, \"No winning bet\");\n\n        claimed[tournamentId][msg.sender] = true;\n\n        uint256 payoutPool = _payoutPool[tournamentId];\n        uint256 seatPool = seatTotals[tournamentId][winningSeat];\n        uint256 payout = (userBet * payoutPool) / seatPool;\n\n        emit WinningsClaimed(tournamentId, msg.sender, payout);\n\n        (bool success, ) = msg.sender.call{ value: payout }(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    // ─────────────────────────────────────────────\n    // View helpers\n    // ─────────────────────────────────────────────\n\n    /**\n     * Get the total pool and per-seat totals for a tournament.\n     */\n    function getBettingPool(uint256 tournamentId)\n        external\n        view\n        returns (uint256 total, uint256[] memory seatAmounts)\n    {\n        (, , , uint8 maxPlayers, ) = pokerVault.tournaments(tournamentId);\n        total = totalPool[tournamentId];\n        seatAmounts = new uint256[](maxPlayers);\n        for (uint256 i = 0; i < maxPlayers; i++) {\n            seatAmounts[i] = seatTotals[tournamentId][i];\n        }\n    }\n\n    /**\n     * Returns the winning seat for a settled tournament, or -1 if not yet settled.\n     */\n    function getWinningSeat(uint256 tournamentId) external view returns (int256) {\n        if (!_settled[tournamentId]) return -1;\n        return int256(_winningSeat[tournamentId]);\n    }\n\n    /**\n     * Returns this bettor's bet amounts on each seat.\n     */\n    function getUserBets(uint256 tournamentId, address bettor)\n        external\n        view\n        returns (uint256[] memory amounts)\n    {\n        (, , , uint8 maxPlayers, ) = pokerVault.tournaments(tournamentId);\n        amounts = new uint256[](maxPlayers);\n        for (uint256 i = 0; i < maxPlayers; i++) {\n            amounts[i] = bets[tournamentId][i][bettor];\n        }\n    }\n\n    /**\n     * Returns the payout pool (after platform fee) for a settled tournament.\n     */\n    function getPayoutPool(uint256 tournamentId) external view returns (uint256) {\n        return _payoutPool[tournamentId];\n    }\n\n    // ─────────────────────────────────────────────\n    // Admin\n    // ─────────────────────────────────────────────\n\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n    }\n\n    function setPlatformFeeBps(uint256 _feeBps) external onlyOwner {\n        require(_feeBps <= 2000, \"Fee too high\"); // max 20%\n        platformFeeBps = _feeBps;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}